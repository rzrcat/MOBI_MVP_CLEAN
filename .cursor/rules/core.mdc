---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
# 📚 마비노기 모바일 커뮤니티 서비스 개발 컨벤션 (최신 통합)

## 1. Overview

- **목적**: 마비노기 모바일 유저를 위한 통합 정보/소통 플랫폼 (도감, 계산기, 트래커, 커뮤니티)
- **주요 스택**:
  - 프론트엔드: React Router 7, React 19, TypeScript 5, Tailwind CSS 4
  - 백엔드: Supabase (PostgreSQL), Drizzle ORM, Node.js
  - UI: Shadcn UI, Radix UI
  - 국제화: i18next, react-i18next
  - 테마: remix-themes (다크/라이트 모드)
  - 모니터링: Sentry
- **아키텍처**: Feature-Sliced Design + 서버리스(Edge Functions)

## 2. 코드 패턴

### 2.1 React & TypeScript

- 함수형 컴포넌트만 사용 (클래스 컴포넌트 금지)
- Props/State/함수 반환값 모두 명확한 타입 지정 (interface/type 활용, any 금지)
- 커스텀 훅: `use` 접두사 사용 (예: `useIsMobile`)
- 상태 관리: React 훅(useState, useContext 등) + Context API
- 함수형/선언적 패턴 우선 (불변성, map/filter/reduce, 순수 함수)
- async/await 우선, 콜백/then 금지
- 코드 중복 최소화(DRY 원칙)
- 불필요한 글로벌 변수, 사이드이펙트 금지
- 함수는 입력값만 변경(불변성), 반환값 외의 상태 변경 금지
- 외부 라이브러리는 꼭 필요한 경우만 사용(의존성 최소화)
- 예외 처리 시 구체적 에러 메시지와 타입 활용
- JSDoc 스타일 문서화: 모든 컴포넌트와 중요 함수에 상세한 주석 필수

### 2.2 API 통신

- Supabase 클라이언트 사용 (server.ts와 client.ts 분리)
- API 응답 처리: React Router의 loader/action 패턴 활용
- 입력 유효성 검사: Zod 스키마 적극 활용
- 모든 API 요청은 try-catch로 감싸고 표준화된 에러 객체 반환
- 쿼리 빌더: Drizzle ORM 사용, SQL 인젝션 방지

### 2.3 스타일링

- Tailwind CSS Only: `@apply` 지양, 유틸리티 클래스 직접 사용
- 클래스 결합: `cn()` 유틸리티 함수 사용
- 컴포넌트 변형: class-variance-authority(cva) 활용
- 레이아웃: CSS Grid + Flexbox 우선, 절대 단위(`px`) 지양
- 다크 모드: `dark:` 클래스 활용 (remix-themes)
- 반응형 디자인: 모바일 우선 접근법, Tailwind 중단점 활용

### 2.4 DB & ORM

- Drizzle ORM: 스키마 정의 시 타입 안전성 확보
- Postgres.js: 네이티브 PostgreSQL 클라이언트
- 관련 파일은 `*.server.ts` 네이밍으로 서버 전용 코드 분리

## 3. 스타일 가이드

### 3.1 네이밍 컨벤션

- 변수/함수: camelCase (예: userProfile, fetchUserData)
- 컴포넌트/타입: PascalCase (예: UserProfile, UserData)
- 파일/폴더: kebab-case (예: form-button.tsx, lang-switcher.tsx)
- 서버 전용 파일: `*.server.ts` 접미사 (예: supa-client.server.ts)

### 3.2 파일 구조

> **아래 폴더 구조는 예시이며, 실제 프로젝트 상황이나 프레임워크(Next.js/Remix 등)에 따라 유연하게 적용하세요. 각 폴더의 역할과 계층화 원칙을 참고해, 팀/비즈니스 상황에 맞게 구조를 조정할 수 있습니다.**

마비노기 모바일 커뮤니티 프로젝트의 실제 구조(Next.js/Remix 기반, app/ 루트, Feature-Sliced Design + 내부 컴포넌트 계층화)를 반영한 폴더 구조 예시:

```
app/
├── core/                  # 공통 핵심 모듈 (db, hooks, layouts, lib 등)
├── features/              # 주요 기능 단위 분리
│   ├── auth/              # 인증 기능
│   ├── blog/              # 블로그 기능
│   ├── contact/           # 문의/연락처 기능
│   ├── cron/              # 예약/스케줄러 기능
│   ├── home/              # 홈/메인 기능
│   ├── legal/             # 법적 고지/정책
│   ├── payments/          # 결제/구매 기능
│   ├── settings/          # 설정/환경설정
│   └── users/             # 유저 관리
│
├── locales/               # 다국어/번역 리소스
├── debug/                 # 디버그/개발 도구
├── public/                # 정적 파일/이미지/스크립트
├── sql/                   # DB 마이그레이션/함수
├── transactional-emails/  # 트랜잭션 이메일 템플릿
├── memory-bank/           # 프로젝트 지식 관리(Memory Bank)
├── e2e/                   # E2E/통합 테스트
│   ├── assets/
│   ├── auth/
│   ├── settings/
│   ├── users/
│   └── utils/
├── .env.example           # 환경 변수 예시
├── package.json           # 패키지/스크립트 관리
├── tsconfig.json          # TypeScript 설정
├── README.md              # 프로젝트 설명
└── ...                    # 기타 설정/메타 파일
```

> **실제 구조와 다를 경우, 도메인 분리/계층화/재사용성 등 핵심 원칙만 유지하고, 프로젝트 특성에 맞게 자유롭게 구조를 조정하세요.**

#### 이 구조가 적합한 이유

1. **도메인 복잡성 관리에 최적화됨**
   - 각 기능이 독립적으로 발전할 수 있으며, 새로운 기능 추가가 용이
2. **비즈니스 로직과 UI의 명확한 분리**
   - hooks/, utils/, api/ 폴더로 비즈니스 로직을 분리하여 테스트 및 유지보수 용이
3. **컴포넌트의 재사용성과 조립성 향상**
   - Atomic Design 개념(atoms → molecules → organisms)으로 UI 컴포넌트를 계층화
4. **실제 유저 흐름과 일치**
   - 폴더 구조가 사용자가 앱을 탐색하는 흐름과 유사
5. **팀 작업과 협업 효율**
   - 기능별 폴더 분리로 여러 개발자가 동시에 작업할 때 충돌 최소화

> Next.js/Remix 등 최신 프레임워크 특성상 `src/` 대신 `app/` 루트를 사용하는 구조가 표준입니다. 실제 프로젝트 구조에 맞게 컨벤션을 유연하게 적용하세요.

### 3.3 컴포넌트 설계

- Atomic Design 원칙 적용 (Atoms → Molecules → Organisms)
- Props Drilling 방지: Context API/React Query 사용

## 4. 테스트

- 단위 테스트: 모든 주요 기능/컴포넌트 필수 (`*.test.tsx`)
- 통합 테스트: 사용자 시나리오 기반 (예: 문의 작성 → 답변 확인)
- 도구: Jest + React Testing Library + MSW (API Mocking)
- 커버리지: 80%+ 목표 (branches/lines/functions)
- 테스트 파일은 `__tests__` 폴더에 위치

## 5. Git & Workflow

- 브랜치 전략: GitHub Flow (main → feature/xxx → PR)
- 커밋 메시지: Conventional Commits 규칙
- PR 전 체크리스트:
  1. `npm run lint` (ESLint)
  2. `npm run test` (테스트)
  3. `npm run build` (빌드)

## 6. Documentation

- Storybook: 모든 UI 컴포넌트 문서화
- JSDoc: 복잡한 함수/훅에 설명 추가

## 7. CI/CD

- GitHub Actions: PR 시 lint/test 자동 실행
- 배포: Vercel/Netlify (프론트엔드), Supabase (백엔드)
- 모니터링: Sentry (에러 추적), UptimeRobot (다운타임 알림)

## 8. Security

- 인증: Supabase Auth + JWT (Access/Refresh Token 분리)
- CORS: API 서버에서 허용 도메인 명시적 설정
- XSS 방지: DOMPurify로 사용자 입력 필터링

## 9. 파일 관리 및 리팩토링 규칙

- **파일 위치 수정**: 리팩토링 시 파일이 올바르지 않은 위치에 있다면 적절한 위치로 이동합니다.
- **중복 파일 처리**: 중복된 파일이 발견되면 올바른 위치의 파일만 남기고 다른 파일은 삭제합니다.
- **지속적인 버그 발생**: 특정 구조에서 버그가 지속적으로 발생한다면 해당 부분을 새로운 구조로 변경하거나 완전히 재작성하는 방법을 고려합니다.
- **코드 변경 이력**: 파일 위치 변경이나 삭제 시 관련 내용을 PR 설명이나 커밋 메시지에 명시합니다.
- **점진적 리팩토링**: 대규모 변경 시 기능 단위로 점진적으로 리팩토링하여 서비스 안정성을 유지합니다.

## 9-1. 타입 정의와 실제 데이터 구조 동기화 원칙

- **타입 정의와 실제 데이터 구조(DB/크롤러/API/프론트)는 항상 일치해야 합니다.**
- 타입스크립트 타입만 변경하거나, 실제 데이터 구조만 변경하는 패치는 금지합니다.
- 타입 정의를 변경할 경우, DB 스키마/크롤러/가공 코드/API/프론트엔드 타입/컴포넌트 등 **모든 계층을 동시에 동기화**해야 합니다.
- 타입-데이터 구조 mismatch가 발생하면 자동화 테스트/스크립트로 즉시 오류/경고/자동수정이 이루어집니다.
- 컨벤션 위반(타입-구조 불일치) 시 자동 경고 및 구조 추적·수정이 실행됩니다.
- 이 원칙은 모든 도메인(도감, 계산기, 트래커, 커뮤니티 등)과 공통 데이터에 일괄 적용됩니다.

## 10. 훅 사용 규칙

- **훅 호출 순서**: React 훅은 항상 컴포넌트 최상위 레벨에서 호출되어야 하며, 조건문이나 반복문 내부에서 호출하지 않습니다.
- **조건부 로직**: 훅 내부에서 조건부 로직을 사용하고, 훅 자체를 조건부로 호출하지 않습니다.
- **커스텀 훅 네이밍**: 모든 커스텀 훅은 'use' 접두사로 시작하며 구체적인 기능을 나타내는 이름을 사용합니다.
- **훅 의존성 배열**: useEffect, useMemo, useCallback의 의존성 배열은 완전하게 작성하며, 필요 시 ESLint 규칙을 활용합니다.
- **서버/클라이언트 훅 분리**: 서버 컴포넌트에서 사용할 수 없는 훅(useState 등)은 명확히 구분하고 'use client' 지시문을 사용합니다.

## 11. 모듈화 및 코드 재사용 원칙

### 11.1 모듈화 단위 정의

- **유틸 함수(Utility Function)**: 순수 로직, 데이터 변환, 계산 등을 담당 (상태나 렌더링과 무관)
- **커스텀 훅(Custom Hook)**: UI와 상태 관리 로직의 재사용 단위 (React 상태 관리와 연결)
- **컴포넌트(Component)**: UI 렌더링과 동작의 재사용 단위 (시각적 요소 포함)
- **서비스(Service)**: 외부 API 통신, 복잡한 비즈니스 로직 처리 등의 기능 단위

### 11.2 재사용 기준

- **유틸 함수**: 2개 이상의 컴포넌트에서 동일한 계산/변환 로직이 필요한 경우
- **커스텀 훅**: 2개 이상의 컴포넌트에서 동일한 상태 관리나 사이드 이펙트 로직이 필요한 경우
- **컴포넌트**: 3개 이상의 곳에서 유사한 UI와 동작이 필요한 경우
- **모듈 크기**: 500라인 이상인 파일은 기능별로 분할 검토

### 11.3 재사용 구현 원칙

- **단일 책임 원칙(SRP)**: 각 모듈은 하나의 기능만 담당하고, 하나의 이유로만 변경되어야 함
- **동일 기능 → 동일 로직**: 컴포넌트가 다르더라도 동일한 기능은 동일한 로직을 재사용
- **기능 기준 모듈화**: 컴포넌트는 유형이 아닌 '기능'을 기준으로 모듈화 (예: 카드 타입별로 나누기보다 다회차 진행 기능/단일 미션 기능으로 분류)
- **명확한 인터페이스**: 모듈 간 통신은 명확한 API/인터페이스로 제한
- **느슨한 결합(Loose Coupling)**: 모듈 간 직접적인 의존성 최소화, 인터페이스에만 의존
- **필요 최소 의존성**: 의존성은 꼭 필요한 것만 포함, 과도한 props/매개변수 지양
- **일관된 인터페이스**: 유사한 유틸/훅/컴포넌트는 일관된 인터페이스 유지
- **문서화**: 재사용 가능한 모든 요소는 간결한 JSDoc 설명 포함
- **추상화 계층 도입**: 구체적 구현보다 인터페이스에 의존하는 설계 채택

### 11.4 재사용 요소 위치

- **전역 재사용 요소**: `/src/shared` 또는 하위 적절한 폴더에 배치
- **도메인 특화 재사용 요소**: 해당 feature 폴더 내 적절한 위치에 배치
- **컴포넌트 내부 재사용 요소**: 컴포넌트 파일 내 helper 함수로 정의

### 11.5 피해야 할 안티패턴

- **거대 모듈(Blob Module)**: 하나의 모듈이 너무 많은 기능을 담당하는 경우
- **순환 의존성**: 모듈 간 A → B → C → A와 같은 의존성 구조 금지
- **과도한 추상화**: 실제 필요보다 많은 계층을 추가하여 가독성 저하
- **전역 상태 남용**: 필요 이상의 전역 상태 사용으로 추적 어려움 발생
- **인라인 스타일/로직 중복**: 공통 스타일이나 로직을 각 컴포넌트에 중복 작성
- **직접적 외부 의존성**: 인터페이스 없이 직접적으로 외부 모듈에 의존하는 구조

### 11.6 모듈화 테스트 전략

- **단위 테스트**: 각 모듈의 개별 기능 검증 (Jest, Testing Library)
- **통합 테스트**: 모듈 간 상호작용 검증 (Cypress, Playwright)
- **모의(Mock) 객체**: 외부 의존성을 가진 모듈 테스트 시 Mock 활용
- **테스트 커버리지**: 모듈 단위 80% 이상의 테스트 커버리지 목표

### 11.7 React 특화 모듈화 패턴

- **컴포넌트 + Custom Hooks 분리**: UI와 로직의 명확한 분리
- **컨텍스트 API**: 적절한 범위의 상태 공유를 위한 Context 활용
- **컴포넌트 합성(Composition)**: 상속보다는 합성을 통한 컴포넌트 재사용
- **고차 컴포넌트(HOC)**: 횡단 관심사(인증, 로깅 등)를 분리하는 패턴 활용

## 12. 버전 관리와 의존성 제어

### 12.1 모듈 버저닝

- **Semantic Versioning(MAJOR.MINOR.PATCH)** 원칙 준수
  - MAJOR: 하위 호환성이 깨지는 변경
  - MINOR: 하위 호환성을 유지하는 기능 추가
  - PATCH: 버그 수정 및 성능 개선
- **변경 이력 문서화**: 모든 주요 모듈/라이브러리의 변경 사항 기록

### 12.2 의존성 관리

- **명시적 버전 지정**: 패키지 매니저(npm)에서 정확한 버전 지정
- **Lock 파일 관리**: `package-lock.json` 파일 필수 커밋, 버전 충돌 방지
- **의존성 정기 검토**: 월 1회 이상 의존성 취약점 및 업데이트 필요성 검토
- **간접 의존성 주의**: 새 라이브러리 도입 시 간접 의존성 영향 고려
- **peer dependencies 관리**: 호환성 문제 방지를 위한 peer dependencies 명확화

### 12.3 의존성 최적화

- **트리 쉐이킹**: 사용하지 않는 코드 제거를 위한 import 최적화
- **지연 로딩**: 필요한 시점에만 모듈을 로드하는 dynamic import 활용
- **번들 크기 모니터링**: 새 의존성 추가 시 번들 크기 영향 검토

## 13. 파일 구조 자동 정리 및 경로 관리 원칙

### 13.1 자동 구조 정리 및 경로 수정

- import 오류, 파일 누락, 중복, 잘못된 위치 등 모든 구조 문제 발생 시
  1. 프로젝트 전체를 스캔하여 실제 파일 존재 여부, 위치, 중복 여부를 파악한다.
  2. 컨벤션(Feature-Sliced Design, shared/ui/atoms 등)에 맞는 위치로 파일을 이동 또는 복구한다.
  3. 누락된 파일이 있으면, 기존 코드/유사 파일/컨벤션을 참고해 자동 생성하거나, 생성이 불가할 경우 어떤 파일이 필요한지 명확히 안내한다.
  4. 중복 파일이 있으면 컨벤션에 맞는 위치의 파일만 남기고 나머지는 삭제한다.
  5. 모든 참조(import) 경로를 자동으로 일괄 수정한다.
  6. 구조 정리 후 빌드/테스트가 정상 동작하는지 확인한다.

### 13.2 적용 예시

- import 오류 → 실제 파일 위치로 이동 및 경로 수정
- 파일 누락 → 유사 파일/컨벤션 기반 자동 생성 또는 안내
- 중복 파일 → 컨벤션 위치만 남기고 삭제
- 잘못된 위치 → 컨벤션 위치로 이동 및 경로 일괄 수정

### 13.3 추가 안내

- 자동 생성이 불가한 파일(예: 완전히 새 기능)은 어떤 파일이 필요한지 명확히 안내한다.
- 구조/위치/누락 문제 발생 시, 오류 메시지나 빌드 결과만 공유하면 자동으로 구조를 정리 및 경로 수정까지 일괄 대응한다.

## 14. 자동화 우선 작업 및 사전/사후 안내 원칙

- 프로젝트에 심각한 문제(데이터 손실, 대규모 기능 삭제, 비가역적 변경 등)를 야기하지 않는 한,  
  직접적인 수동 개입 없이 모든 구조/경로/중복/누락/머지 충돌/빌드 오류/컨벤션 위반 등 문제를  
  **자동으로 진단, 수정, 이동, 생성, 삭제, 경로 변경 등 필요한 작업을 즉시 진행**한다.

- 모든 자동 작업은  
  "어떤 작업을 왜, 어떻게 진행하는지"  
  작업 전/후 또는 작업 중간에  
  **명확하게 설명**한다.

- 심각한 데이터 손실, 대규모 삭제, 비가역적 변경 등은 반드시 사전 안내 및 승인 후 진행한다.

- 자동화 우선, 사전 설명 및 사후 보고 원칙을 따른다.

## 15. 개발 일지 자동 기록 원칙

- 개발자가 "개발 종료"를 명시적으로 지시하거나, 하루(24시간)가 지나면  
  **그날 작업한 모든 내역을 자동으로 노션(Notion)에 기록**한다.

- 기록 대상 페이지:

  - **개발기록**: 상세 작업 내역, 주요 이슈, 해결 과정, 리팩토링/구조 변경 등 구체적 개발 히스토리
  - **개발진행현황**: 전체 진행률, 완료/진행/대기 중인 주요 작업, 남은 과제 등 현황 요약

- 기록 방식:

  1. 자동으로 작업 내역을 정리하여 각 페이지에 맞는 형식으로 업로드한다.
  2. 기록 시점, 작업자, 주요 변경점, 자동화/수동 작업 여부, 특이사항 등을 명확히 남긴다.
  3. 기록이 완료되면 개발자에게 요약 결과를 안내한다.

- 개발 일지 자동 기록은 프로젝트 투명성, 협업, 회고, 이슈 추적을 위해 필수적으로 수행한다.

## 16. 기능 개발 및 명세 관리 자동화 원칙

- 새로운 기능 개발 또는 리팩토링 시,  
  **기획서(요구사항 문서)를 참고하여 현재 프로젝트 상태를 점검**하고  
  **기능 명세 목록을 자동으로 업데이트**한다.

- 기능 명세 목록은 다음과 같이 관리한다:

  1. **기획서와 실제 코드/구조를 비교**하여 누락된 기능, 미완성/진행 중 기능, 완료된 기능을 자동으로 식별한다.
  2. 기능별로 상태(완료/진행중/대기/미정), 담당자, 예상 일정, 관련 이슈 등을 기록한다.
  3. 모든 변경/추가/완료 내역은 **기능 명세 목록 페이지**에 자동으로 기록한다.

- 기능 명세 목록 페이지에는 다음 정보가 포함되어야 한다:

  - 기능명, 설명, 상태, 담당자, 일정, 관련 이슈/PR, 참고 기획서 링크 등

- 기능 명세 목록은 항상 최신 상태로 유지하며,  
  **기능 개발/변경/완료 시 자동으로 반영**한다.

- 기록 및 업데이트가 완료되면 개발자에게 요약 결과를 안내한다.

## 17. 파일 자동 접근 및 수정 규칙

- 파일의 위치가 프로젝트 내에 있을 것으로 추정되는 경우(예: import 경로, 컨벤션상 위치, 유사 파일명 등)
  - 별도의 사용자 요청이나 승인 없이,
  - 자동으로 해당 파일을 읽고, 수정(생성/이동/삭제/내용 변경 등) 작업을 진행한다.
- 작업 전/후에는 어떤 파일을 왜 읽거나 썼는지 명확하게 안내한다.
- 파일이 실제로 존재하지 않거나, 자동 생성이 불가한 경우에만 사용자에게 추가 안내 또는 요청을 한다.

## 18. 오류 수정 자동화 및 스크립트 생성 규칙

- 빌드, 테스트, 타입, import, 경로, 구조 등 모든 오류가 발생하면
  1. 자동으로 원인을 진단하고, 컨벤션에 맞게 직접 수정 작업을 즉시 진행한다.
  2. 자동으로 수정이 불가능하거나 복잡한 경우에는
     - 스스로 필요한 스크립트(예: Node.js, bash 등)를 생성하여
     - 해당 스크립트를 직접 실행해 오류를 해결한다.
- 모든 자동화/스크립트 작업 전후에는 어떤 오류를 어떻게 수정하는지 명확하게 안내한다.
- 스크립트 실행 후에도 해결되지 않는 경우, 추가 안내 또는 수동 개입이 필요한 부분을 명확히 안내한다.

## 19. 컨벤션 문서와 코드 패치 분리 원칙

- 컨벤션 문서(`.mdc`, `.md` 등)에는 import 구문, 함수 정의 등 실제 코드가 포함되어서는 안 된다.
- 컨벤션 문서에는 규칙, 원칙, 예시, 설명만 작성한다.
- 실제 코드(예: import, 함수, 변수 등) 변경은 반드시 해당 소스코드 파일(`.ts`, `.tsx` 등)에만 적용한다.
- 문서에는 "이런 식으로 수정하세요"라는 예시/설명만 남기고, 실제 코드는 코드 파일에만 반영한다.
- 코드 패치와 문서 업데이트는 항상 명확히 분리하여 관리한다.

## [필수] 모든 구현/수정 시 이 컨벤션을 반드시 확인하고, 위 원칙에 맞춰 작업할 것!

- 코드리뷰, PR, QA 시에도 본 컨벤션 준수 여부를 항상 체크한다.

## 20. 플랫폼(OS)별 개발 환경 호환성 원칙

- macOS, Windows, Linux 등 다양한 OS에서 동일하게 동작하는 코드/구조를 유지한다.
- import 경로는 항상 소문자, 확장자 생략, 대소문자 혼용 금지(Windows는 구분X, macOS/Linux는 구분O)
- node_modules, 패키지 import, 타입 선언 등은 cross-platform 호환성을 고려해 작성한다.
- require() 대신 ESM import 사용, 경로 구분자는 path.join 등 cross-platform 방식 적용
- npm/yarn/pnpm 스크립트는 OS별 실행 환경 차이를 고려해 작성한다.
- .env, 권한, 실행 파일 등 OS별 차이 발생 시 컨벤션/문서에 명확히 안내한다.
- 빌드/테스트/배포는 모든 OS에서 동일하게 통과해야 하며, 환경별 이슈 발생 시 즉시 컨벤션에 반영한다.

### [실전 체크리스트 및 권장 설정]

- **Node.js/NPM 버전 통일**: nvm(macOS), nvm-windows(Windows) 등으로 Node.js, npm 버전을 맞추고, package-lock.json을 항상 커밋/동기화한다.
- **import 경로/파일명 대소문자 일치**: 실제 파일명과 100% 일치하도록 작성하고, CI에서 대소문자 경로 체크(lint, test) 필수.
- **.env 파일**: UTF-8로 저장, macOS는 chmod로 권한 관리, Windows는 속성 변경. 경로는 항상 상대경로/소문자 사용.
- **Git 라인 엔딩(CRLF/LF) 통일**: .gitattributes에 `* text=auto` 또는 `* text eol=lf` 명시, 에디터/IDE에서 LF로 통일 권장.
- **cross-env 등 cross-platform 스크립트 사용**: npm script에서 환경변수 등은 cross-env로 통일, 쉘 스크립트는 node.js로 대체 권장.
- **경로 구분자**: 코드에서 경로는 `/` 사용, node.js의 path.join 등 cross-platform 함수 사용.
- **실행 파일/권한**: macOS는 실행 권한 필요, Windows는 필요 없음. git에서 권한 비트 관리 주의.
- **node_modules/바이너리**: OS별로 바이너리가 다를 수 있으니, 항상 npm install로 재설치.

> 위 체크리스트를 모든 개발자가 숙지하고, 실제로 OS를 오가며 작업할 때 발생할 수 있는 문제를 사전에 예방하세요.

## 21. 자동화 스크립트 관리 원칙

- 자동화/임시/유틸리티 스크립트(`scripts/` 하위에 생성된 _.js, _.ts 등)는 실행 후 즉시 삭제한다.
- 작업 이력 및 결과는 커밋/대화/문서로만 남기고, 불필요한 임시 파일이 프로젝트에 남지 않도록 한다.
- 이 원칙은 모든 자동화/임시 스크립트 작업에 일관되게 적용한다.

## 22. 문서화 스타일 가이드

- **파일 헤더 JSDoc**: 모든 파일 상단에 다음 정보를 포함한 JSDoc 주석 작성:
  - 컴포넌트/모듈 이름과 목적
  - 주요 기능 설명
  - 사용 예시 또는 맥락
  - 관련 기능/컴포넌트와의 관계

- **함수/컴포넌트 JSDoc**: 모든 중요 함수와 컴포넌트에 다음 정보를 포함한 JSDoc 주석 작성:
  - 기능 설명
  - 매개변수와 반환값
  - 예외 처리 또는 특별한 동작
  - 예시(필요한 경우)

- **복잡한 로직 인라인 주석**: 복잡한 로직이나 비즈니스 규칙에는 인라인 주석 추가

- **JSDoc 형식**:
  ```typescript
  /**
   * 컴포넌트/함수 이름
   *
   * 주요 기능에 대한 상세 설명
   * 여러 줄로 작성 가능
   *
   * @param paramName - 매개변수 설명
   * @returns 반환값 설명
   */
  ```

## 23. React Router 패턴 가이드

- **데이터 로딩**: loader 함수 사용
  - 페이지 렌더링에 필요한 데이터는 loader에서 로드
  - useLoaderData/useRouteLoaderData 훅으로 데이터 접근

- **폼 처리**: action 함수 사용
  - 폼 제출, 데이터 변경 등은 action에서 처리
  - 유효성 검사는 Zod 스키마 활용

- **타입 안전성**: Route 타입 정의 활용
  - `Route.LoaderArgs`, `Route.ActionArgs`, `Route.MetaFunction` 등 타입 지정

- **메타데이터**: meta 함수로 SEO 데이터 제공
  - 페이지 제목, 설명 등 정의
  - i18n과 연계하여 다국어 메타데이터 지원

- **에러 처리**: ErrorBoundary 컴포넌트 활용
  - 예상치 못한 오류에 대한 대응
  - 사용자 친화적인 오류 메시지 표시







