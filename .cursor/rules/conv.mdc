---
description: 
globs: 
alwaysApply: true
---
# 📚 마비노기 모바일 커뮤니티 서비스 개발 컨벤션 (최신 통합)

## 1. Overview

- **목적**: 마비노기 모바일 유저를 위한 통합 정보/소통 플랫폼 (도감, 계산기, 트래커, 커뮤니티)
- **주요 스택**:
  - 프론트엔드: Next.js/Remix, React 18, TypeScript 5, Tailwind CSS
  - 백엔드: Supabase (PostgreSQL), Drizzle ORM, Node.js
  - UI: Shadcn UI, Radix UI
- **아키텍처**: Feature-Sliced Design + 서버리스(Edge Functions)

## 2. 코드 패턴

### 2.1 React & TypeScript

- 함수형 컴포넌트만 사용 (클래스 컴포넌트 금지)
- Props/State/함수 반환값 모두 명확한 타입 지정 (interface/type 활용, any 금지)
- 커스텀 훅: `use-` 접두사 사용 (예: `useUserTracker`)
- 상태 관리: React Query + Zustand (복잡한 전역 상태 시)
- 함수형/선언적 패턴 우선 (불변성, map/filter/reduce, 순수 함수)
- async/await 우선, 콜백/then 금지
- 코드 중복 최소화(DRY 원칙)
- 불필요한 글로벌 변수, 사이드이펙트 금지
- 함수는 입력값만 변경(불변성), 반환값 외의 상태 변경 금지
- 외부 라이브러리는 꼭 필요한 경우만 사용(의존성 최소화)
- 예외 처리 시 구체적 에러 메시지와 타입 활용

### 2.2 API 통신

- Axios 인스턴스만 사용 (Base URL, 인터셉터 통합)
- API 응답 타입: `APIResponse<T>` 제네릭 타입으로 표준화
- 모든 API 요청은 try-catch로 감싸고 표준화된 에러 객체 반환
- 쿼리 빌더: SQL 인젝션 방지 위해 Prepared Statements만 사용

### 2.3 스타일링

- Tailwind CSS Only: `@apply` 지양, 유틸리티 클래스 직접 사용
- 레이아웃: CSS Grid + Flexbox 우선, 절대 단위(`px`) 지양
- 다크 모드: `dark:` 클래스 활용 (Next.js ThemeProvider)
- CSS 클래스명: BEM 방식 + Tailwind CSS만 사용 (별도 CSS/SASS 금지)

### 2.4 DB & ORM

- Drizzle ORM: 스키마 정의 시 `pg()`와 `mysql()` 분리하지 않고 추상화
- 쿼리 빌더: SQL 인젝션 방지 위해 Prepared Statements만 사용

## 3. 스타일 가이드

### 3.1 네이밍 컨벤션

- 변수/함수: camelCase (예: userProfile, fetchUserData)
- 컴포넌트/타입: PascalCase (예: UserProfile, UserData)
- 파일/폴더: kebab-case (예: user-profile.tsx, api-handlers)

### 3.2 파일 구조

마비노기 모바일 커뮤니티 프로젝트 특성(도감, 계산기, 트래커, 커뮤니티)에 최적화된
**Feature-Sliced Design + 내부 컴포넌트 계층화**를 결합한 폴더 구조:

```
src/
├── features/                # 주요 기능 단위 분리
│   ├── codex/               # 도감 기능
│   │   ├── components/      # 도감 관련 컴포넌트
│   │   │   ├── atoms/       # 기본 UI 요소 (카드, 배지, 필터, 아이콘)
│   │   │   ├── molecules/   # 결합된 UI (필터바, 정렬선택기, 카드그룹)
│   │   │   └── organisms/   # 완성된 섹션 (룬목록, 코디목록, 상세뷰)
│   │   ├── hooks/           # 도감 관련 훅 (useRuneDetails, useOutfitFilters)
│   │   ├── utils/           # 도감 관련 유틸리티 (데이터 변환, 필터링 로직)
│   │   ├── types/           # 도감 관련 타입 정의
│   │   └── api/             # 도감 데이터 관련 API 호출
│   │
│   ├── tracker/             # 트래커 기능
│   │   ├── components/      # 유사한 계층화...
│   │   └── ...
│   │
│   ├── calculator/          # 계산기 기능
│   │   └── ...
│   │
│   └── community/           # 커뮤니티 기능
│       └── ...
│
├── shared/                  # 공통 요소
│   ├── ui/                  # 범용 UI 컴포넌트
│   │   ├── atoms/           # 기본 UI (버튼, 입력필드, 아이콘 등)
│   │   ├── molecules/       # 복합 UI (폼, 탭, 모달 등)
│   │   └── templates/       # 레이아웃 템플릿 (섹션, 카드레이아웃 등)
│   │
│   ├── hooks/               # 공통 훅 (useAuth, useToast, useDeviceInfo 등)
│   ├── utils/               # 공통 유틸리티 (날짜, 포맷팅, 검증 등)
│   ├── api/                 # API 인스턴스, 인터셉터, 공통 응답 핸들링
│   ├── store/               # 전역 상태 관리 (Zustand 스토어)
│   └── types/               # 공통 타입 정의
│
├── services/                # 서비스 레이어
│   ├── auth/                # 인증 관련 서비스
│   ├── notification/        # 알림 서비스
│   ├── crawler/             # 크롤링 서비스
│   └── storage/             # 스토리지 서비스
│
├── app/                     # Next.js App Router 페이지
│   ├── (auth)/              # 인증 관련 라우트
│   ├── codex/               # 도감 페이지
│   ├── calculator/          # 계산기 페이지
│   ├── tracker/             # 트래커 페이지
│   └── community/           # 커뮤니티 페이지
│
└── __tests__/              # 테스트 파일 (기능별 폴더 구조 반영)
```

#### 이 구조가 적합한 이유

1. **도메인 복잡성 관리에 최적화됨**

   - 도감, 계산기, 트래커, 커뮤니티 등 다양한 도메인 경계를 명확히 분리
   - 각 기능이 독립적으로 발전할 수 있으며, 새로운 기능 추가가 용이

2. **비즈니스 로직과 UI의 명확한 분리**

   - 복잡한 게임 데이터 처리 로직을 UI 컴포넌트와 분리
   - hooks/, utils/, api/ 폴더로 비즈니스 로직을 분리하여 테스트 및 유지보수 용이

3. **컴포넌트의 재사용성과 조립성 향상**

   - Atomic Design 개념(atoms → molecules → organisms)으로 UI 컴포넌트를 계층화
   - 작은 컴포넌트 조합으로 복잡한 UI를 구성하여 코드 중복 최소화

4. **실제 유저 흐름과 일치**

   - 폴더 구조가 사용자가 앱을 탐색하는 흐름과 유사
   - 실제 사용자 워크플로우가 폴더 구조에 자연스럽게 반영

5. **팀 작업과 협업 효율**
   - 기능별 폴더 분리로 여러 개발자가 동시에 작업할 때 충돌 최소화
   - 기능 단위로 PR, 리뷰, 테스트가 가능해 협업 워크플로우 단순화

### 3.3 컴포넌트 설계

- Atomic Design 원칙 적용 (Atoms → Molecules → Organisms)
- Props Drilling 방지: Context API/React Query 사용

### 3.4 UI/UX 디자인 원칙 및 참고 자료

- 모든 UI/UX 설계는 **Apple Human Interface Guidelines(애플 공식 디자인 가이드)**를 기반으로 한다.
- **Figma(iOS 18 스타일) 등 제공된 참고 자료를 반드시 확인**하고, 참고 자료의 스타일에서 벗어나지 않도록 한다.
- UI 스타일 구현 시 **직접 CSS 작성은 지양**하고, **Tailwind CSS 및 shadcn UI 컴포넌트**를 우선 활용한다.
- 디자인/스타일링 작업 시, **참고 자료와 실제 구현 결과가 일치하는지 반드시 검토**한다.

### 3.5 디자인 토큰 시스템 및 글로벌 스타일 관리

- **디자인 토큰(Design Token)이란?**  
  색상, 폰트, 폰트 사이즈, 간격, 그림자, 라운드 등 UI 스타일 속성을 변수로 추상화한 값.  
  코드, Figma, 문서 등에서 동일한 이름과 값으로 관리하여 일관성과 유지보수성을 높인다.

- **디자인 토큰 선언 위치**

  - **CSS 변수(:root)**
    - `src/app/globals.css`(또는 프로젝트의 글로벌 스타일 파일) 내 `:root`에 선언
    - 예시:
      ```css
      :root {
        --color-primary: #007aff;
        --font-size-title-1: 28px;
        --radius-medium: 10px;
      }
      ```
  - **Tailwind config**
    - `tailwind.config.js`의 `theme.extend`에 CSS 변수와 동일한 이름/값으로 확장
    - 예시:
      ```js
      theme: {
        extend: {
          colors: { primary: 'var(--color-primary)' },
          fontSize: { 'title-1': 'var(--font-size-title-1)' },
          borderRadius: { md: 'var(--radius-medium)' },
        }
      }
      ```
  - **Figma 등 디자인 툴**
    - 동일한 토큰명/값으로 관리(디자인-개발 협업 시 필수)

- **글로벌 스타일 관리 원칙**

  - **글로벌 스타일(globals.css)에는 :root 디자인 토큰 선언과 body, h1~h6 등 기본 스타일만 작성한다.**
  - **폰트 사이즈, 라인하이트, 자간 등 스타일 속성은 반드시 디자인 토큰을 통해 관리한다.**
  - **컴포넌트/유틸리티 클래스에서는 var(--토큰명) 또는 Tailwind 유틸리티를 사용한다.**
  - **폰트 파일 임포트 및 @font-face 선언은 fonts.css에서만 담당하며, 스타일링(사이즈, 라인하이트 등)은 절대 포함하지 않는다.**
  - **글로벌 스타일, Tailwind config, Figma 등에서 토큰 값이 항상 일치하도록 관리한다.**
  - **다크모드/테마 등은 :root, [data-theme], .dark 등에서 토큰 값만 변경하여 전체 UI에 일관되게 반영한다.**

- **적용 예시**

  - `fonts.css`
    - @font-face, font-family, font-weight 등 폰트 파일 임포트 및 선언만 담당
  - `globals.css`
    - :root에 디자인 토큰(CSS 변수) 선언
    - body, h1~h6 등 글로벌 스타일에서 var(--토큰명) 사용
  - `tailwind.config.js`
    - theme.extend에 디자인 토큰과 동일한 값으로 확장
    - Tailwind 유틸리티로 일관성 있게 사용

- **이 원칙을 따르면**
  - 디자인 시스템, 다크모드, 테마, 반응형, 유지보수, 협업 모두에 최적화된 구조를 만들 수 있다.

---

#### 📌 추가 권장 문구

> - **폰트 파일 임포트 및 @font-face 선언은 반드시 fonts.css에서만 작성하고, 폰트 사이즈/라인하이트/자간 등 스타일링은 반드시 globals.css(:root 디자인 토큰) 또는 Tailwind config에서 관리한다.**
> - **글로벌 스타일, Tailwind config, Figma 등에서 디자인 토큰 값이 항상 일치하도록 관리한다.**
> - **컴포넌트/페이지/유틸리티에서는 반드시 디자인 토큰 또는 Tailwind 유틸리티를 사용한다.**
> - **디자인 토큰이 변경될 경우, 관련된 글로벌 스타일, Tailwind config, Figma 등 모든 곳에 즉시 반영하여 일관성을 유지한다.**
> - **글로벌 스타일 파일(globals.css)에는 reset, base, typography 등 프로젝트 전체에 적용되는 스타일만 작성하고, 개별 컴포넌트 스타일은 각 컴포넌트 파일에서 Tailwind 유틸리티로 작성한다.**

### 3.6 UI 스냅샷 테스트

- 주요 UI 컴포넌트/페이지는 **Jest, Storybook, Chromatic** 등으로 스냅샷 테스트를 작성한다.
- 스냅샷 테스트는 컴포넌트의 렌더링 결과(HTML/CSS 또는 이미지)를 저장해두고, 코드 변경 시 결과가 달라지면 자동으로 감지한다.
- 스냅샷 테스트를 통해 의도치 않은 UI 변경, 디자인 일관성 훼손을 빠르게 발견할 수 있다.
- 예시(Jest):
  ```ts
  import { render } from '@testing-library/react';
  import MyButton from './MyButton';
  test('MyButton UI snapshot', () => {
    const { container } = render(<MyButton label="확인" />);
    expect(container).toMatchSnapshot();
  });
  ```

### 3.7 Atomic Design + Variants 패턴 강화

- Atoms, Molecules, Organisms 계층 내에서 **Variants(상태별 스타일)**를 props 또는 별도 객체로 명확히 분리해 관리한다.
- 예: 버튼, 카드 등은 `variant`, `size`, `disabled` 등 다양한 상태/테마를 한 곳에서 관리하며, 중복을 최소화한다.
- Variants 패턴을 통해 컴포넌트의 재사용성과 유지보수성을 높이고, UI 일관성을 유지한다.
- 예시:
  ```tsx
  // Button.tsx
  export interface ButtonProps {
    variant?: 'primary' | 'secondary' | 'danger';
    size?: 'sm' | 'md' | 'lg';
    disabled?: boolean;
    // ...
  }
  export const Button = ({
    variant = 'primary',
    size = 'md',
    ...props
  }: ButtonProps) => {
    const className = getButtonClassName(variant, size);
    return <button className={className} {...props} />;
  };
  ```

## 4. 테스트

- 단위 테스트: 모든 주요 기능/컴포넌트 필수 (`*.test.tsx`)
- 통합 테스트: 사용자 시나리오 기반 (예: 문의 작성 → 답변 확인)
- 도구: Jest + React Testing Library + MSW (API Mocking)
- 커버리지: 80%+ 목표 (branches/lines/functions)
- 테스트 파일은 `__tests__` 폴더에 위치

## 5. Git & Workflow

- 브랜치 전략: GitHub Flow (main → feature/xxx → PR)
- 커밋 메시지: Conventional Commits 규칙
- PR 전 체크리스트:
  1. `npm run lint` (ESLint)
  2. `npm run test` (테스트)
  3. `npm run build` (빌드)

## 6. Documentation

- Storybook: 모든 UI 컴포넌트 문서화
- JSDoc: 복잡한 함수/훅에 설명 추가

## 7. CI/CD

- GitHub Actions: PR 시 lint/test 자동 실행
- 배포: Vercel/Netlify (프론트엔드), Supabase (백엔드)
- 모니터링: Sentry (에러 추적), UptimeRobot (다운타임 알림)

## 8. Security

- 인증: Supabase Auth + JWT (Access/Refresh Token 분리)
- CORS: API 서버에서 허용 도메인 명시적 설정
- XSS 방지: DOMPurify로 사용자 입력 필터링

## 9. 파일 관리 및 리팩토링 규칙

- **파일 위치 수정**: 리팩토링 시 파일이 올바르지 않은 위치에 있다면 적절한 위치로 이동합니다.
- **중복 파일 처리**: 중복된 파일이 발견되면 올바른 위치의 파일만 남기고 다른 파일은 삭제합니다.
- **지속적인 버그 발생**: 특정 구조에서 버그가 지속적으로 발생한다면 해당 부분을 새로운 구조로 변경하거나 완전히 재작성하는 방법을 고려합니다.
- **코드 변경 이력**: 파일 위치 변경이나 삭제 시 관련 내용을 PR 설명이나 커밋 메시지에 명시합니다.
- **점진적 리팩토링**: 대규모 변경 시 기능 단위로 점진적으로 리팩토링하여 서비스 안정성을 유지합니다.

## 10. 훅 사용 규칙

- **훅 호출 순서**: React 훅은 항상 컴포넌트 최상위 레벨에서 호출되어야 하며, 조건문이나 반복문 내부에서 호출하지 않습니다.
- **조건부 로직**: 훅 내부에서 조건부 로직을 사용하고, 훅 자체를 조건부로 호출하지 않습니다.
- **커스텀 훅 네이밍**: 모든 커스텀 훅은 'use' 접두사로 시작하며 구체적인 기능을 나타내는 이름을 사용합니다.
- **훅 의존성 배열**: useEffect, useMemo, useCallback의 의존성 배열은 완전하게 작성하며, 필요 시 ESLint 규칙을 활용합니다.
- **서버/클라이언트 훅 분리**: 서버 컴포넌트에서 사용할 수 없는 훅(useState 등)은 명확히 구분하고 'use client' 지시문을 사용합니다.

## 11. 모듈화 및 코드 재사용 원칙

### 11.1 모듈화 단위 정의

- **유틸 함수(Utility Function)**: 순수 로직, 데이터 변환, 계산 등을 담당 (상태나 렌더링과 무관)
- **커스텀 훅(Custom Hook)**: UI와 상태 관리 로직의 재사용 단위 (React 상태 관리와 연결)
- **컴포넌트(Component)**: UI 렌더링과 동작의 재사용 단위 (시각적 요소 포함)
- **서비스(Service)**: 외부 API 통신, 복잡한 비즈니스 로직 처리 등의 기능 단위

### 11.2 재사용 기준

- **유틸 함수**: 2개 이상의 컴포넌트에서 동일한 계산/변환 로직이 필요한 경우
- **커스텀 훅**: 2개 이상의 컴포넌트에서 동일한 상태 관리나 사이드 이펙트 로직이 필요한 경우
- **컴포넌트**: 3개 이상의 곳에서 유사한 UI와 동작이 필요한 경우
- **모듈 크기**: 500라인 이상인 파일은 기능별로 분할 검토

### 11.3 재사용 구현 원칙

- **단일 책임 원칙(SRP)**: 각 모듈은 하나의 기능만 담당하고, 하나의 이유로만 변경되어야 함
- **동일 기능 → 동일 로직**: 컴포넌트가 다르더라도 동일한 기능은 동일한 로직을 재사용
- **기능 기준 모듈화**: 컴포넌트는 유형이 아닌 '기능'을 기준으로 모듈화 (예: 카드 타입별로 나누기보다 다회차 진행 기능/단일 미션 기능으로 분류)
- **명확한 인터페이스**: 모듈 간 통신은 명확한 API/인터페이스로 제한
- **느슨한 결합(Loose Coupling)**: 모듈 간 직접적인 의존성 최소화, 인터페이스에만 의존
- **필요 최소 의존성**: 의존성은 꼭 필요한 것만 포함, 과도한 props/매개변수 지양
- **일관된 인터페이스**: 유사한 유틸/훅/컴포넌트는 일관된 인터페이스 유지
- **문서화**: 재사용 가능한 모든 요소는 간결한 JSDoc 설명 포함
- **추상화 계층 도입**: 구체적 구현보다 인터페이스에 의존하는 설계 채택

### 11.4 재사용 요소 위치

- **전역 재사용 요소**: `/src/shared` 또는 하위 적절한 폴더에 배치
- **도메인 특화 재사용 요소**: 해당 feature 폴더 내 적절한 위치에 배치
- **컴포넌트 내부 재사용 요소**: 컴포넌트 파일 내 helper 함수로 정의

### 11.5 피해야 할 안티패턴

- **거대 모듈(Blob Module)**: 하나의 모듈이 너무 많은 기능을 담당하는 경우
- **순환 의존성**: 모듈 간 A → B → C → A와 같은 의존성 구조 금지
- **과도한 추상화**: 실제 필요보다 많은 계층을 추가하여 가독성 저하
- **전역 상태 남용**: 필요 이상의 전역 상태 사용으로 추적 어려움 발생
- **인라인 스타일/로직 중복**: 공통 스타일이나 로직을 각 컴포넌트에 중복 작성
- **직접적 외부 의존성**: 인터페이스 없이 직접적으로 외부 모듈에 의존하는 구조

### 11.6 모듈화 테스트 전략

- **단위 테스트**: 각 모듈의 개별 기능 검증 (Jest, Testing Library)
- **통합 테스트**: 모듈 간 상호작용 검증 (Cypress, Playwright)
- **모의(Mock) 객체**: 외부 의존성을 가진 모듈 테스트 시 Mock 활용
- **테스트 커버리지**: 모듈 단위 80% 이상의 테스트 커버리지 목표

### 11.7 React 특화 모듈화 패턴

- **컴포넌트 + Custom Hooks 분리**: UI와 로직의 명확한 분리
- **컨텍스트 API**: 적절한 범위의 상태 공유를 위한 Context 활용
- **컴포넌트 합성(Composition)**: 상속보다는 합성을 통한 컴포넌트 재사용
- **고차 컴포넌트(HOC)**: 횡단 관심사(인증, 로깅 등)를 분리하는 패턴 활용

## 12. 버전 관리와 의존성 제어

### 12.1 모듈 버저닝

- **Semantic Versioning(MAJOR.MINOR.PATCH)** 원칙 준수
  - MAJOR: 하위 호환성이 깨지는 변경
  - MINOR: 하위 호환성을 유지하는 기능 추가
  - PATCH: 버그 수정 및 성능 개선
- **변경 이력 문서화**: 모든 주요 모듈/라이브러리의 변경 사항 기록

### 12.2 의존성 관리

- **명시적 버전 지정**: 패키지 매니저(npm)에서 정확한 버전 지정
- **Lock 파일 관리**: `package-lock.json` 파일 필수 커밋, 버전 충돌 방지
- **의존성 정기 검토**: 월 1회 이상 의존성 취약점 및 업데이트 필요성 검토
- **간접 의존성 주의**: 새 라이브러리 도입 시 간접 의존성 영향 고려
- **peer dependencies 관리**: 호환성 문제 방지를 위한 peer dependencies 명확화

### 12.3 의존성 최적화

- **트리 쉐이킹**: 사용하지 않는 코드 제거를 위한 import 최적화
- **지연 로딩**: 필요한 시점에만 모듈을 로드하는 dynamic import 활용
- **번들 크기 모니터링**: 새 의존성 추가 시 번들 크기 영향 검토

## 12. 리팩토링 후 검증 절차

### 12.1 파일 구조 검증

- **중복/불필요 파일 검사**: 리팩토링 후에는 반드시 중복된 파일이나 불필요한 파일이 남아있는지 확인합니다.
- **경로 적합성 검사**: 모든 파일이 컨벤션에 정의된 올바른 위치에 존재하는지 확인합니다.
- **폴더 구조 정리**: 비어있는 폴더는 삭제하고, 일관된 폴더 구조를 유지합니다.

### 12.2 참조 경로 업데이트

- **import 경로 수정**: 파일을 이동하거나 삭제한 경우, 해당 파일을 참조하는 모든 곳의 import 경로를 수정합니다.
- **단계적 리팩토링**: 대규모 리팩토링 시 import 오류를 방지하기 위해 단계적으로 진행하고 각 단계마다 빌드 테스트를 수행합니다.
- **타입 참조 확인**: 특히 TypeScript에서 타입 정의 파일의 위치가 변경된 경우, 모든 타입 참조가 올바르게 업데이트되었는지 확인합니다.

### 12.3 디버깅 및 문제 해결 전략

- **시도 횟수 제한**: 동일한 문제를 3회 이상 디버깅 시도했으나 해결되지 않을 경우, 다른 접근 방식이나 설계를 고려합니다.
- **근본 원인 분석**: 반복되는 버그의 경우, 증상이 아닌 근본 원인을 해결하는 방향으로 접근합니다.
- **대안 설계 준비**: 현재 구조에서 지속적인 문제가 발생한다면, 해당 부분을 완전히 재설계하는 것도 고려합니다.

### 12.4 리팩토링 검증 체크리스트

1. 모든 기능이 예상대로 작동하는지 확인
2. 불필요한 파일이 남아있지 않은지 확인
3. 모든 import 경로가 올바르게 업데이트되었는지 확인
4. 빌드 및 테스트가 성공적으로 완료되는지 확인
5. 성능에 부정적인 영향이 없는지 확인
6. 코드 스타일과 컨벤션이 일관되게 유지되는지 확인

## [필수] 모든 구현/수정 시 이 컨벤션을 반드시 확인하고, 위 원칙에 맞춰 작업할 것!

- 코드리뷰, PR, QA 시에도 본 컨벤션 준수 여부를 항상 체크한다.
